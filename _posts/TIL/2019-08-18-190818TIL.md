---

layout: single

title: "2019-08-18 TIL"
categories:
  - TIL
tags:
  - [TIL]

---

- ##  [C++복습 / 씹어먹는 C++] 10-1 강 벡터/리스트/데크  

  ### STL 컨테이너(container)

  1. 컨테이너는 크게 2 종류로 나누어진다.
     - 시퀀스 컨테이너(Sequence Container) : 인덱스에 따라 원소를 순서대로 보관하는 컨테이너로써 vector, list, deque 등이 있다.
     - 연관 컨테이너(Associative ) : 키(key) - 값(value) 구조를 가지는 컨테이너로써 set, map, hash 등이 있다.

  2. 범위 기반 for 문 (range based for loop)

  C++ 11 에서 컨테이너의 원소를 반복하는 패턴을 간단하게 나타낼 수 있는 새로운 방식

  ```
  for (const auto& data : vec)
  	std::cout <<< "원소 값 : " << data << std::endl;
  ```

  #### vector

    가변 배열과 같다고 생각하면 된다.

  1. 시간복잡도
     - 임의의 위치 원소 접근 ***O(1)***
     - 맨 뒤에 원소 추가 및 제거 ***amortized O(1)*** (평균적으로 ***O(1)*** 이지만, 메모리 재할당을 할경우 ***O(n)***)
     - 임의의 위치 원소 추가 및 제거 ***O(n)***

  #### list

    양방향 리스트로 구현되어 있으며, 반복자를 사용할 때 1칸씩 밖에 이동하지 못한다.

  1. 시간복잡도
     - 임의의 위치 원소 접근 ***O(n)***
     - 임의의 위치 원소 추가 및 제거 ***O(1)*** (단, 반복자가 해당 위치에 접근해 있어야 한다)

  #### deque

    vector와 같은 기능에 맨 앞의 원소를 추가/제거 가능하며, 임의의 위치의 원소 추가/제거가 벡터보다

    약간 더 빠르지만, **원소들이 실제로 연속적으로 존재하지 않으며, 메모리가 추가적으로 필요하다**.

  1. 시간복잡도
     - 임의의 위치 원소 접근 ***O(1)***
     - 맨 '앞 또는 맨 뒤에 원소 추가 및 제거***O(1)***
     - 임의의 위치 원소 추가 및 제거 ***O(n)***

- ## [C++복습 / 씹어먹는 C++] 10-2 강 셋/맵  

  ### STL 컨테이너(container)
  
  특정 키 값을 가지는 데이터가 존재하는지만 확인하고 싶을 경우 Set을 사용하고, 키 값에 따른 데이터를 확인하고 싶을 경우 Map을 사용하는 것이 좋다.
  
  #### set
  
    해당 key값을 가지는 데이터가 존재하는지 확인하기 위한 컨테이너. 
  
  1. 시간복잡도
  
     - 원소를 추가 및 제거 ***O(logN)***
  
     - 특정 원소 찾기 ***O(logN)***
  
       ![](https://user-images.githubusercontent.com/18680116/63221862-01e00280-c1da-11e9-8974-36bcba58a0c1.png)
  
  2. 원소는 순서가 없으며(key로 구별하기 때문에), 중복되는 원소가 없고(key에 따른 data가 없기 때문에), 자동으로 정렬된다.
  
     - 사용자 정의 클래스를 key값으로 사용하기 위해서는 operator < 를 만들어주어야 한다. 그리고 다음과 같은 조건을 만족해야한다.
  
       * `A < A` 는 거짓
  
       - `A < B != B < A`
  
       - `A < B` 이고 `B < C` 이면 `A < C`
  
       - `A == B` 이면 `A < B` 와 B `< A` 둘 다 거짓
  
       - `A == B` 이고 `B == C` 이면 `A == C`
  
  #### map
  
    key 와 data로 구성돼있는 컨테이너
  
  1. 시간복잡도
     - 임의의 위
  2. key 값에 따라서 자동으로 정렬된다. 원소를 추가할 때 pair 타입으로 추가하거나 [] 연산자를 통해 추가/변경할 수 있다.
  
  #### multiset, multimap
  
  1. 원소의 중복을 허용하기 때문에 [] 연산자를 사용할 수 없다. key값이 중복되는 원소에 find 함수를 사용할 때 어떤 값이 반환될지 알 수 없다. 이러한 단점을 극복하기 위해 begin()과 end()를 가지는 pair를 반환하는 equal_range(key) 함수를 제공한다.
  
  #### unordered_set, unordered_map
  
  1. 정렬되지 않지만 삽입/삭제/탐색 이 ***O(1)*** 로 수행된다.
  
  2. 해시함수(Hash function)을 사용할 때 **해시 크기(메모리 크기와 비슷)가 원소의 갯수보다 적으면 다른 원소간의 해시 값이 같은 해시 충돌(Hash collision)이 발생할 수 있다**. 해시 충돌이 일어날 경우 같은 해시값을 같은 원소안에서 다시 탐색해야 원하는 원소를 찾을 수 있으므로 최악의경우 ***O(N)***의 시간복잡도가 소요된다.
  
  3. 사용자 지정 클래스를 사용하고 싶을 경우 해시 함수를 만들어주어야한다. 기본적인 데이터 타입의 해시 함수는 C++에서 제공하므로 이를 조합해서 만들 수 있다. 
  
     > 하지만 일반적으로 해시 함수가 지원되지 않는 unordered 컨테이너는 만들지 않는 것이 일반적이다.
  
- ### [백준] 10816 문제 풀이

  탐색시간을 줄이는 문제, 숫자 배열이 주어지고 각 숫자의 갯수가 몇개인지를 출력하면 되는 문제. 정렬이 필요 없기 때문에 unordered_map 을 사용하여 숫자의 갯수를 저장하여서 해결.
  
- ### [백준] [200 문제 풀이 달성](https://www.acmicpc.net/user/totok682) (쉬운것도 많지만..)