---

layout: default

parent: .NET
title: ".NET GC 정리(1) (작성중)"
use_math: true
---

### .NET GC 정리(1)

인터넷 여기저기 흩어져있는 GC 관련정보를 쉬운부분부터 어려운 부분까지 정리.

#### 누구나 아는 내용
다음은 누구나 아는 내용이고 .NET 버전이 달라져도 동일한 내용 (.NET 7까지는..)
- **CLR이 제공하는 메모리 수집 기능 GC**
C#, ASP.NET 등 .NET 환경에서 개발한 프로그램은 CLR(Common Language Runtime) 위에서 프로그램이 돌아간다. 메모리 수집을 사용자가 아닌 CLR이 맡아서 하게된다. 이 기능을 GC라고 한다.  

- **.NET의 GC는 Mark/Swap 방식**
메모리를 해제하는 방법에는 크게 Reference count와 Mark and sweep 기법이 있다. .NET은 Mark and sweep 기법을 사용한다. 사용하고 있는 객체를 마킹하고 마킹이 없는 메모리를 전부 해제한다.

- **.NET은 세대별 GC**
Mark/Sweep 기법은 메모리를 뒤지며 해제해도 되는 객체를 찾아야한다. 메모리를 전부 뒤지는 것은 비용이 어마어마하므로 최근에 생성한 객체만 우선 정리하기 위해 메모리를 세대로 나눈 기법.

- **GC는 힙 메모리가 부족할 때 발생한다 (다른 경우도 있음)**
  - 스택영역은 GC가 회수하지 않는다. 콜스택이 끝나면(`=코드 블록이 끝나는 시점`) 알아서 사라진다.
  - 새로운 객체를 만들때 공간이 부족하면(`=남은 공간이 threshold를 넘을 경우`, `threshold는 실행중 계속 업데이트된다.`) GC를 시작한다.


이제부터는 헷갈리는 주제들을 하나씩 정리해보고자 한다.

#### 2세대 & LOH
#### WorkStation GC / Server GC
.NET의 GC는 WGC(WorkStation GC), SGC(Server GC)로 나뉘는데 둘의 차이는 간단하다.
- WGC는 힙이 1개, SGC는 힙이 N개(`=논리 코어 갯수`)다.
- 힙의 갯수가 많으므로 SGC가 당연히 메모리를 더 많이 차지한다. 단, [힙 1개당 크기는 환경에 따라 다르다.](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals)
- SGC는 멀티코어에서만 가능하다. 싱글코어면 병렬처리를 못하는데 힙이 여러개여서 얻을 이득이 전혀없다.

WGC와 SGC를 세팅하는 방법은 config에서 다음과 같이 설정하면 끝이다.
```
<gcServer enabled="true"/>
```

#### Non-concurrent GC / Concurrent GC
WGC/SGC는 블락킹이 발생하냐 백그라운드에서 수집되냐의 차이가 아니다.
Concurrent 세팅에 따라서 달라진다.

- Concurrent 세팅은 2세대 GC만 백그라운드에서 진행하는 기능. 0/1세대는 스레드가 전부 멈추고(`= 이걸 Stop The World (STW)라고 한다`) GC를 수행.

0/1세대의 GC는 비교적 짧은 시간내에 완료되지만 2세대 GC는 매우 오래걸리는 작업이다. 크기도 크고 Concurrent를 해도 STW는 발생한다.
