---

layout: single

title: "2019-09-18 TIL"
categories:
  - TIL
tags:
  - [TIL, Algorithm]

---

- ## [백준] [1167 문제 풀이](https://github.com/JangHyeonJun/Algorithm/blob/master/Algorithms/1167.cpp)

  트리 문제(2), 트리의 지름을 찾는 문제. 

    문제풀이는 DFS로 해결할 수 있다. 그러나 시간복잡도와 공간복잡도를 둘다 고려해야되는 문제.

  - 정점(V)의 갯수가 100,000개 이기 때문에 V*V 그래프로 문제를 풀 경우 100억개의 정수형 변수를 답는 2차원 배열이므로 메모리를 매우 많이 사용하게 된다.

    - 이전의 그래프나 트리를 통한 노드를 사용하는 문제들 처럼 노드간 간선의 가중치또는 연결정보만을 가지고 풀어야한다. 동적 2차원 배열을 사용하여 해결하였다.

  - 시간 제한이 2초이므로 `O(n^2)`의 시간복잡도를 가지게 될 경우 V가 최대 10만개이므로 최소 100억번의 연산을 하게 된다. 컴퓨터는 일반적으로 1초에 1억번의 연산을 할수 있다는 가정하에 100초나 걸리게 된다.

    - 이를 해결하기 위해 우선 노드를 모두 탐색하는 것이 아닌 연결된 간선의 개수로 탐색 횟수를 줄여볼 수 있다. 하지만 연결된 간수만 탐색하는 방식을 써도 결국 모든 노드의 최단거리를 계산해야하기 때문에 `o(n^2)`을 벗어나지 못한다.
    - 시간복잡도를 줄이기 위해 트리의 지름을 구할 때 임의의 노드 A에서 가장 먼 노드 B로 부터 가장 긴 거리가 지름이 된다는 공식을 사용하면 시간을 더욱 단축시켜 통과할 수 있다.

    

- ## [백준] [1967 문제 풀이](https://github.com/JangHyeonJun/Algorithm/blob/master/Algorithms/1967.cpp)

  트리 문제(3), 트리의 지름을 찾는 문제. 위 문제와 같은 정보가 주어지므로 알고리즘을 그대로 사용하되 입력받는 과정만 바꾸어도 된다.
  
- 백트래킹 문제(3), 중복 조합을 찾는 문제이다. 쉽다.

- ## [백준] [2437 문제 풀이](https://github.com/JangHyeonJun/Algorithm/blob/master/Algorithms/2437.cpp)

  탐욕 알고리즘 문제, 주어진 수열로 만들 수 없는 최소값을 찾는 문제.
  
    수열을 우선 오름차순으로 정렬한 후, 이전 원소까지의 누적합으로 `1 ~ n` 의 값을 표현할 수 있고 다음 원소의 무게가 `w` 라면 `1 ~ (n + w)`의 값을 표현할 수 있게된다. 단 `w <= n+1 ` 이어야 한다.
  
    이진법에서 각 자릿수로 나타낼 수 있는 최대 합을 생각하면 더욱 쉽게 이해할 수 있다.
  
  
  
- ## ToDo

  - A* 복습하기, DP, 그리디 복습하기
  - 인공지능 이론 복습하기


